/***********************************
 test complex operation
 author : Doug Young Suh
 date   : 99.9.17

  Revision 1: 2000.8.25 Doug Young Suh 
   include fft test.
  Revision 2: 2013. 1. 8 
   Read an image and fft line by line
  Revision 3: 2014. 4. 30  ==> delete
   add two more test
   (square) <--> (sinc)
   (sinc)   <--> (square)
  Revision 4: 2014. 5. 11
   only 1 dimensional FFT  (Fft1D.hpp Fft1D.cpp)
  Revision 5: 2019. 5. 11
   use the complex class in C++
   stdio.h --> fstream
***************************************/
//#include <stdio.h>
//#include <stdlib.h>
//#include <conio.h>
#include <iostream>
#include <fstream>
#include <complex>
#include "fft1D.hpp"
#include <ctime>
void main()
{

	// define
	ofstream fff("FFTofSquare.txt"),ggg("IFFTofLPF.txt");
	ofstream kkk("DFTofSquare.txt"), lll("IDFTofLPF.txt");
	long n,k;
	FFT *sequence;
	DFT *dft;
	int N = 512;
	sequence = new FFT(N);
	dft = new DFT(N);
	clock_t start, end, diff;
	double t1, t2, t3, t4;
	
	// test 1: FFT of square x[n]
	start = clock();
	for(n=0;n<N;n++)    sequence->x[n] = complex<Real>(0.0,0.0);
	for(n=0;n<16;n++)   sequence->x[n] = complex<Real>(1.0,0.0);
	for(n=N-15;n<N;n++) sequence->x[n] = complex<Real>(1.0,0.0);
	sequence->ForwardFFT();
	if(!fff) {
		cout << "cant open FFTofSquare.txt.\n";
		exit(333);
	}
	
	for(k=N/2;k<N-1;k++) fff << real(sequence->X[k]) << endl;
	for(k=0;k<N/2+1;k++) fff << real(sequence->X[k]) << endl;
    fff.close();
	end = clock();
	t1 = (double)(end - start) / CLOCKS_PER_SEC;

	// test 2: FFT of ideal low pass filter X[k]
	start = clock();
	for(k=0;k<N;k++)    sequence->X[k] = complex<Real>(0.0,0.0);
	for(k=0;k<16;k++)   sequence->X[k] = complex<Real>(1.0,0.0);
	for(k=N-15;k<N;k++) sequence->X[k] = complex<Real>(1.0,0.0);
	sequence->InverseFFT();
	if(!ggg) {
		cout << "cant open IFFTofLPF.txt.\n";
		exit(334);
	}
	for(n=N/2;n<N-1;n++) ggg << real(sequence->x[n]) << endl;
	for(n=0;n<N/2+1;n++) ggg << real(sequence->x[n]) << endl;
    ggg.close();
	end = clock();
	t2 = (double)(end - start) / CLOCKS_PER_SEC;


	// test 3: DFT of square x[n]
	start = clock();
	for (n = 0; n<N; n++)    dft->x[n] = complex<Real>(0.0, 0.0);
	for (n = 0; n<16; n++)   dft->x[n] = complex<Real>(1.0, 0.0);
	for (n = N - 15; n<N; n++) dft->x[n] = complex<Real>(1.0, 0.0);

	dft->ForwardDFT();
	if (!kkk) {
		cout << "cant open DFTofSquare.txt.\n";
		exit(333);
	}
	for (k = N / 2; k<N - 1; k++) kkk << real(dft->X[k]) << endl;
	for (k = 0; k<N / 2 + 1; k++) kkk << real(dft->X[k]) << endl;
	kkk.close();
	end = clock();

	t3 = (double)(end - start) / CLOCKS_PER_SEC;


	// test 4: FFT of ideal low pass filter X[k]
	start = clock();
	for (k = 0; k<N; k++)    dft->X[k] = complex<Real>(0.0, 0.0);
	for (k = 0; k<16; k++)   dft->X[k] = complex<Real>(1.0, 0.0);
	for (k = N - 15; k<N; k++) dft->X[k] = complex<Real>(1.0, 0.0);

	dft->InverseDFT();
	if (!lll) {
		cout << "cant open IDFTofLPF.txt.\n";
		exit(334);
	}
	for (n = N / 2; n<N - 1; n++) lll << real(dft->x[n]) << endl;
	for (n = 0; n<N / 2 + 1; n++) lll << real(dft->x[n]) << endl;
	lll .close();
	end = clock();
	t4 = (double)(end - start) / CLOCKS_PER_SEC;

	cout << t1 << endl << t2 << endl << t3 << endl << t4 << endl;
	//cout << end << " - " << start << " = " << (double)(end - start) / CLOCKS_PER_SEC << endl;
	system("pause");
	return;
}

